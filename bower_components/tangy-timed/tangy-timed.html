<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../paper-card/paper-card.html">

<dom-module id="tangy-timed">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    <paper-card>
      <span class="countdown">[[timeRemaining]]‚è±</span>
      <span> [[statusMessage]] </span>
      <div>
        <button on-click="clickedStart">start timer</button>
        <button on-click="clickedStop">stop timer</button>
        <button on-click="clickedReset">reset timer</button>
      </div>
      <slot></slot>
    </paper-card>
 
  </template>

  <script>
    /**
     * `tangy-timed`
     * 
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class TangyTimed extends Polymer.Element {
      static get is() { return 'tangy-timed'; }
      static get properties() {
        return {
          prop1: {
            type: String,
            value: 'tangy-timed'
          },
          timeRemaining: {
            type: Number,
            value: 60 
          },
          timeSpent: {
            type: Number,
            value: 0 
          },
          statusMessage: {
            type: String,
            value: 'Click start to begin'
          }
        };
      }

      // Element class can define custom element reactions
      connectedCallback() {
        super.connectedCallback();
        console.log('my-element created!');
      }
    
      ready() {
        super.ready();
        this.inputElements = this.inputElements = Array.prototype.slice.call(this.querySelectorAll('input'));
        this.inputElements.forEach(element => element.disabled = true);
        this.inputElements.forEach(element => {
          element.addEventListener('click', (event) => {
            if (this.lastSelectedMode === true) {
              this.removeLastSelected();
              // That last click will cause the opposite of what we want. Put it back to the original state.
              event.srcElement.checked = !event.srcElement.checked;
              // Style the label.
              const labelEl = event.srcElement.labels[0];
              // @TODO: This won't work because Angular styles don't work on native elements. Really?
              labelEl.className = 'lastInput';
              // ... but inline styles do.
              labelEl.setAttribute('style', 'color:red; border: 1px solid blue;'); ;
              this.statusMessage = 'You may now proceed.';
              /*
              // @TODO Show some visual indication of the status of this being valid and done. Maybe similar to
              // ... TangerineFormCardComponent that animates to Green when complete.
              // Set hidden variables.
              // Last selected id.
              const lastSelectedIdInputEl = this.elementRef.nativeElement.querySelector('#' + this.id + '_last_selected_id');
              lastSelectedIdInputEl.value = event.srcElement.id;
              lastSelectedIdInputEl.dispatchEvent(new Event('change', {bubbles: true}));
              // Last selected nth item.
              const lastSelectedNthInputEl = this.elementRef.nativeElement.querySelector('#' + this.id + '_last_selected_nth');
              lastSelectedNthInputEl.value = this.inputElements.findIndex((el) => el.id === event.srcElement.id) + 1;
              lastSelectedNthInputEl.dispatchEvent(new Event('change', {bubbles: true}));
              // items per minute
              const itemsPerMinuteInputEl = this.elementRef.nativeElement.querySelector('#' + this.id + '_items_per_minute');
              itemsPerMinuteInputEl.value = ( lastSelectedNthInputEl.value / ( this.timeSpent / 60 ) );
              itemsPerMinuteInputEl.dispatchEvent(new Event('change', {bubbles: true}));
              // Items marked is number of checkboxes checked.
              const itemsNumberOfItemsMarkedInputEl = this.elementRef.nativeElement.querySelector('#' + this.id + '_number_of_items_marked');
              itemsNumberOfItemsMarkedInputEl.value = this.inputElements.filter((element) => {
                return element.type === 'checkbox' && element.checked === true;
              }).length;
              itemsNumberOfItemsMarkedInputEl.dispatchEvent(new Event('change', {bubbles: true}));
              */
            }
          });
        });

      }
      clickedReset() {
        this.removeLastSelected();
        this.lastSelectedMode = false;
        this.timeRemaining = this.duration;
        this.timeSpent = 0;
        if (this.timer.state === 'notScheduled') {
          this.statusMessage = 'You may click start to begin again.';
        }
      }
    
      clickedStart() {
        console.log('yut')
        // Prevent double starts.
        if (this.timeSpent === 0) {
          // @TODO Should disable start timer button to provide visual indication you can't click it again.
          this.statusMessage = 'Timer is running.';
          this.inputElements.forEach((element) => element.disabled = false);
          this.timer = setInterval(() => {
            this.timeRemaining--;
            this.timeSpent++;
            if (this.timeRemaining === 0) {
              clearInterval(this.timer);
              this.timeIsUp();
            }
          }, 1000);
        }
      }
    
      clickedPause() {
        // @TODO: Do we need pause/resume?
      }
    
      clickedStop() {
        clearInterval(this.timer);
        // @TODO Last item covered should be a feature you opt into. Not relevant to all things timed.
        // @TODO Disabling prevent last item from being selected.
        // this.inputElements.forEach(element => element.disabled = true);
        this.statusMessage = 'Click the last item covered.';
        this.lastSelectedMode = true;
      }
    
      timeIsUp() {
        this.lastSelectedMode = true;
        this.statusMessage = 'Time is up, click the last item covered.';
      }
    
      removeLastSelected() {
        this.inputElements.forEach(cleanupElement => {
          if (cleanupElement.labels && cleanupElement.labels.length > 0) {
            const cleanupLabelEl = cleanupElement.labels[0];
            cleanupLabelEl.setAttribute('style', ''); ;
          }
        });
      }
    
    }

    window.customElements.define(TangyTimed.is, TangyTimed);
  </script>
</dom-module>
